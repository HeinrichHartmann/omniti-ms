From d0df9ef75404944888616e6dfd5a469edeb074fd Mon Sep 17 00:00:00 2001
From: Theo Schlossnagle <jesus@omniti.com>
Date: Mon, 16 Sep 2013 14:53:22 +0000
Subject: [PATCH 2/2] TS-2211 SSL client connections hang and a aborted due to
 inactivity.

Part two: ssl reads and writes can fail to complete due to an
inverted demand. Need to read to write more or write to read more.
The SSL_read cases seem correct, but the SSL_write cases did not
correctly account of read requirements.  This change extends the
relevant calls to track what is actually needed to complete the call
and feeds that back into actions on the event system.
---
 iocore/net/P_SSLNetVConnection.h  |  3 +--
 iocore/net/P_UnixNetVConnection.h |  2 +-
 iocore/net/SSLNetVConnection.cc   | 11 +++++++++--
 iocore/net/UnixNetVConnection.cc  | 29 +++++++++++++++++++++++------
 4 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/iocore/net/P_SSLNetVConnection.h b/iocore/net/P_SSLNetVConnection.h
index f96d718..990a8dc 100644
--- a/iocore/net/P_SSLNetVConnection.h
+++ b/iocore/net/P_SSLNetVConnection.h
@@ -89,8 +89,7 @@ public:
   int sslServerHandShakeEvent(int &err);
   int sslClientHandShakeEvent(int &err);
   virtual void net_read_io(NetHandler * nh, EThread * lthread);
-  virtual int64_t load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf);
-
+  virtual int64_t load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf, int &needs);
   void registerNextProtocolSet(const SSLNextProtocolSet *);
 
   ////////////////////////////////////////////////////////////
diff --git a/iocore/net/P_UnixNetVConnection.h b/iocore/net/P_UnixNetVConnection.h
index ac1eca9..abdf4ba 100644
--- a/iocore/net/P_UnixNetVConnection.h
+++ b/iocore/net/P_UnixNetVConnection.h
@@ -182,7 +182,7 @@ public:
     (void) state;
   }
   virtual void net_read_io(NetHandler *nh, EThread *lthread);
-  virtual int64_t load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf);
+  virtual int64_t load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf, int &needs);
   void readDisable(NetHandler *nh);
   void readSignalError(NetHandler *nh, int err);
   int readSignalDone(int event, NetHandler *nh);
diff --git a/iocore/net/SSLNetVConnection.cc b/iocore/net/SSLNetVConnection.cc
index 86e788e..fde9117 100644
--- a/iocore/net/SSLNetVConnection.cc
+++ b/iocore/net/SSLNetVConnection.cc
@@ -326,7 +326,7 @@ SSLNetVConnection::net_read_io(NetHandler *nh, EThread *lthread)
 
 
 int64_t
-SSLNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf)
+SSLNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf, int &needs)
 {
   ProxyMutex *mutex = this_ethread()->mutex;
   int64_t r = 0;
@@ -369,6 +369,8 @@ SSLNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, i
   if (r > 0) {
     if (total_wrote != wattempted) {
       Debug("ssl", "SSLNetVConnection::loadBufferAndCallWrite, wrote some bytes, but not all requested.");
+      // I'm not sure how this could happen. We should have tried and hit an EAGAIN.
+      needs |= EVENTIO_WRITE;
       return (r);
     } else {
       Debug("ssl", "SSLNetVConnection::loadBufferAndCallWrite, write successful.");
@@ -381,9 +383,14 @@ SSLNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, i
     case SSL_ERROR_NONE:
       Debug("ssl", "SSL_write-SSL_ERROR_NONE");
       break;
-    case SSL_ERROR_WANT_WRITE:
     case SSL_ERROR_WANT_READ:
+      needs |= EVENTIO_READ;
+      r = -EAGAIN;
+      Debug("ssl", "SSL_write-SSL_ERROR_WANT_READ");
+      break;
+    case SSL_ERROR_WANT_WRITE:
     case SSL_ERROR_WANT_X509_LOOKUP:
+      needs |= EVENTIO_WRITE;
       r = -EAGAIN;
       Debug("ssl", "SSL_write-SSL_ERROR_WANT_WRITE");
       break;
diff --git a/iocore/net/UnixNetVConnection.cc b/iocore/net/UnixNetVConnection.cc
index 86889ae..a7dc08e 100644
--- a/iocore/net/UnixNetVConnection.cc
+++ b/iocore/net/UnixNetVConnection.cc
@@ -384,7 +384,10 @@ write_to_net_io(NetHandler *nh, UnixNetVConnection *vc, EThread *thread)
       nh->read_ready_list.remove(vc);
       vc->write.triggered = 0;
       nh->write_ready_list.remove(vc);
-      write_reschedule(nh, vc);
+      if (ret == SSL_HANDSHAKE_WANT_READ || ret == SSL_HANDSHAKE_WANT_ACCEPT)
+        read_reschedule(nh, vc);
+      else
+        write_reschedule(nh, vc);
     } else if (ret == EVENT_DONE) {
       vc->write.triggered = 1;
       if (vc->write.enabled)
@@ -438,7 +441,8 @@ write_to_net_io(NetHandler *nh, UnixNetVConnection *vc, EThread *thread)
   }
 
   int64_t total_wrote = 0, wattempted = 0;
-  int64_t r = vc->load_buffer_and_write(towrite, wattempted, total_wrote, buf);
+  int needs = 0;
+  int64_t r = vc->load_buffer_and_write(towrite, wattempted, total_wrote, buf, needs);
 
   // if we have already moved some bytes successfully, summarize in r
   if (total_wrote != wattempted) {
@@ -451,8 +455,16 @@ write_to_net_io(NetHandler *nh, UnixNetVConnection *vc, EThread *thread)
   if (r <= 0) {                 // if the socket was not ready,add to WaitList
     if (r == -EAGAIN || r == -ENOTCONN) {
       NET_DEBUG_COUNT_DYN_STAT(net_calls_to_write_nodata_stat, 1);
-      vc->write.triggered = 0;
-      nh->write_ready_list.remove(vc);
+      if((needs & EVENTIO_WRITE) == EVENTIO_WRITE) {
+        vc->write.triggered = 0;
+        nh->write_ready_list.remove(vc);
+        write_reschedule(nh, vc);
+      }
+      if((needs & EVENTIO_READ) == EVENTIO_READ) {
+        vc->read.triggered = 0;
+        nh->read_ready_list.remove(vc);
+        read_reschedule(nh, vc);
+      }
       return;
     }
     if (!r || r == -ECONNRESET) {
@@ -493,7 +503,12 @@ write_to_net_io(NetHandler *nh, UnixNetVConnection *vc, EThread *thread)
       return;
     }
 
-    write_reschedule(nh, vc);
+    if((needs & EVENTIO_WRITE) == EVENTIO_WRITE) {
+      write_reschedule(nh, vc);
+    }
+    if((needs & EVENTIO_READ) == EVENTIO_READ) {
+      read_reschedule(nh, vc);
+    }
     return;
   }
 }
@@ -823,7 +838,7 @@ UnixNetVConnection::net_read_io(NetHandler *nh, EThread *lthread)
 // (SSL read does not support overlapped i/o)
 // without duplicating all the code in write_to_net.
 int64_t
-UnixNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf)
+UnixNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted, int64_t &total_wrote, MIOBufferAccessor & buf, int &needs)
 {
   int64_t r = 0;
 
@@ -868,6 +883,8 @@ UnixNetVConnection::load_buffer_and_write(int64_t towrite, int64_t &wattempted,
     NET_DEBUG_COUNT_DYN_STAT(net_calls_to_write_stat, 1);
   } while (r == wattempted && total_wrote < towrite);
 
+  needs |= EVENTIO_WRITE;
+
   return (r);
 }
 
-- 
1.8.1.3

